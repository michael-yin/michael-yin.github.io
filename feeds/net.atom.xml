<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Michaelyin's Blog</title><link href="http://blog.michaelyin.info/" rel="alternate"></link><link href="http://blog.michaelyin.info/feeds/net.atom.xml" rel="self"></link><id>http://blog.michaelyin.info/</id><updated>2012-02-22T13:06:00+08:00</updated><entry><title>Winform中的Control.Invoke&amp;Control.BeginInvoke</title><link href="http://blog.michaelyin.info/2012/02/22/winform-invokecontrol-begininvoke/" rel="alternate"></link><updated>2012-02-22T13:06:00+08:00</updated><author><name>Michaelyin</name></author><id>tag:blog.michaelyin.info,2012-02-22:2012/02/22/winform-invokecontrol-begininvoke/</id><summary type="html">&lt;p&gt;最近由于毕业论文的原因接触了下Winform，以前对于Control.BeginInvoke和delegate下的同样的方法的区别不是很清楚，这次借着这次机会把这个知识点好好补了一下。&lt;/p&gt;
&lt;p&gt;先来说说Winform中的Control吧，Winform中的控件是运行在UI线程中的，而不是工作线程（可以通过InvokeRequired来进行判断是不是安全的），所以如果我们在工作线程中对其的属性进行修改的话，那么多线程的时候就会产生问题。所以微软是不建议这样操作的&lt;/p&gt;
&lt;p&gt;那么如果我需要控件完成某个事情，我需要怎么做呢？这时候Control.Invoke的作用就体现出来了。这里需要注意的是有两个一个是Invoke,另外一个是BeginInvoke，那么这两者有什么区别呢？&lt;/p&gt;
&lt;p&gt;如果后台工作线程需要对UI这个线程的方法调用进行等待那么就用Invoke,如果不需要等待，，当传入的方法执行完毕后工作线程继续执行的，那么就用BeginInvoke，两者的区别仅仅在于是否阻塞工作线程,&lt;strong&gt;而传入的方法其实都是在UI线程内执行的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而delegate的BeginInvoke其实是新开辟的一个线程，在这个新开辟的线程中执行这个方法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="nf"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;button1_Click&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt; &lt;span class="nx"&gt;sender&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;EventArgs&lt;/span&gt; &lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="nx"&gt;Func&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   
        &lt;span class="nx"&gt;MessageBox.Show&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;Thread&lt;/span&gt;&lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;CurrentThread.ManagedThreadId.ToString&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;asdf&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;

    &lt;span class="nx"&gt;func.BeginInvoke&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;null&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;null&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在VS中Debug/Windows/Threads可以查看运行的进程&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/yuyijq/archive/2010/01/11/1643802.html"&gt;http://www.cnblogs.com/yuyijq/archive/2010/01/11/1643802.html&lt;/a&gt;&lt;/p&gt;</summary></entry><entry><title>char,int转换</title><link href="http://blog.michaelyin.info/2011/03/10/char-convert-int/" rel="alternate"></link><updated>2011-03-10T02:42:00+08:00</updated><author><name>Michaelyin</name></author><id>tag:blog.michaelyin.info,2011-03-10:2011/03/10/char-convert-int/</id><summary type="html">&lt;p&gt;写一个Console小程序的时候需要用户输入数字，然后在程序中进行获取，本来以为很简单的，没想到也发生了一些曲折。。&lt;/p&gt;
&lt;p&gt;在Console类中，Console.Read获取的用户输入的单个字符，.net内存中的字符的存储都是采用的Unicode编码，所以这个方法返回的是该字符的Unicode编码的十进制值，对于Unicode不是很了解的朋友可以参考我的另外一篇Post&lt;a href="http://www.cnblogs.com/MichaelYin/archive/2010/12/06/1897928.html"&gt;字符编码那些事儿&lt;/a&gt;，如果我需要得到这个字符具体是多少，只需要调用Convert.ToChar就可以了。来看个例子&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Convert&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ToChar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在Console窗口中按Ctrl+空格打开中文输入法，这样可以在Console中输入中文，然后敲随便一个中文，比如’我’,设置断点可以发现运行到第二行的时候变量c的值是’我’,这样基本就告诉我们了其中的一些基本的原理。就想我前面说的Console.Read返回的是’我’这个字符的Unicode编码的值，如果我们输入’3’,那么a并不是3，而是3的Unicode编码的值，也就是51。&lt;/p&gt;
&lt;p&gt;这个51在程序中已经是int类型了，如果我们需要重新得到原始的Char，使用方法Convert.ToChar就可以。&lt;/p&gt;
&lt;p&gt;实际中另外一种情况是，我在Console中输入数字，希望在程序中重新得到数字,这时候，上面的方法就不行了，因为它只能得到char.&lt;/p&gt;
&lt;p&gt;有的朋友可能会说，Convert类中包含了基本类型的转换，直接用不就行了么，的确,Convert类中确实有Convert.ToInt32方法用于将char转换为int,但是，这个转换是基于2进制实际值的转换，也就是说，我将字符’3’放进去，得到的结果是字符’3’的二进制表示的int值，也就是51.&lt;/p&gt;
&lt;p&gt;园子里有的人用的是int.parse的方法，这个方法使用每次必须将char转换成string类型才行，实现是可以实现，但是每次都转换成string，感觉十分的丑陋。&lt;/p&gt;
&lt;p&gt;在文档里面找了一下，发现了这个方法。GetNumericValue，直接提供了char到int的转换，可以将字符’3’直接转换为double类型。&lt;/p&gt;</summary></entry><entry><title>这不是基础中的基础么</title><link href="http://blog.michaelyin.info/2011/03/02/static-function/" rel="alternate"></link><updated>2011-03-02T16:09:00+08:00</updated><author><name>Michaelyin</name></author><id>tag:blog.michaelyin.info,2011-03-02:2011/03/02/static-function/</id><summary type="html">&lt;p&gt;中午在园子里逛的时候看到了一个评论头条的&lt;a href="http://www.cnblogs.com/jirigala/archive/2011/03/01/1968192.html"&gt;博文&lt;/a&gt;，吉日嘎拉纠正了自己的错误认识。里面涉及到的东西说实话确实很基础，不过我看了下评论却没有将问题解释清楚，至于标题借用了老赵的评论。&lt;/p&gt;
&lt;p&gt;先说说方法表，方法表位于内存中的Loader
Heap，它包含着类对应的方法，在类加载的时候会在Load
Heap上创建和相应的类对应的方法表。当类实例化的时候，托管堆上除了将对象实例化所需要的字段分配内存以外，还会给一个叫做TypeHandle的给实例，这样新建的实例就可以根据TypeHandle在Loader
Heap中找到它所对应的类型的方法表，进而找到对应的方法。&lt;/p&gt;
&lt;p&gt;在这里借用下Anytao的图。。可能大家看的更懂一些\~&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.michaelyin.info/images/2011/03/20110303000835615.jpg"&gt;&lt;img alt="20110303000835615" src="http://blog.michaelyin.info/images/2011/03/20110303000835615.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;到这里停顿一下，说开了实例方法和静态方法其实在内存中都是存储在这个类所对应的方法表上，而且重要的是，它们在内存里面都只有一份，实例调用的方法也是通过TypeHandle找到对应的方法表而完成的方法的调用的。&lt;/p&gt;
&lt;p&gt;在来说说方法的调用，在大学学过C的都必定折腾过实参，形参，也知道为什么有的时候为什么调用C语言函数的时候要传入指针，如果你把那个地方搞的比较清楚的话那么这里想必也难不倒你了。C语言函数调用的时候是在内存上重新开辟一块区域，然后在这个里面运行函数并进行相应的处理并返回结果，运行完成之后释放所有的局部变量。在.Net里面方法的调用也是这个过程，分配动态内存进行方法的处理。&lt;/p&gt;
&lt;p&gt;吉日嘎拉博文中纠结的并发还是排队其实仔细想象就会有答案，这两种处理方式产生的原因是因为对资源的占用问题，就是说不同线程里面有没有可能产生资源占用的问题，上面已经说到了方法调用是分配到内存里面进行处理，不同的方法在内存中所处的位置显然是不相同的。所以一般情况下这个是能够并发的，除非是在不同的内存中又涉及到了访问公有区域的位置，比如访问静态变量。&lt;/p&gt;
&lt;p&gt;到这里基本上就把问题解释的比较清楚了，不过从那篇博客的评论中可以看到还是有不少的人对于基础东西缺乏了解，同时也建议想提高自己水平的编程者关注业务的同时多多注重基础知识的学习，每天抽点时间看点书，积累一点，时间久了就会质变\~&lt;/p&gt;</summary></entry><entry><title>由类能否包含自己说开去</title><link href="http://blog.michaelyin.info/2010/12/13/class-can-contain-itself/" rel="alternate"></link><updated>2010-12-13T08:47:00+08:00</updated><author><name>Michaelyin</name></author><id>tag:blog.michaelyin.info,2010-12-13:2010/12/13/class-can-contain-itself/</id><summary type="html">&lt;p&gt;下午在Coding的时候突然想到了一个问题，类到底能不能包含自己?在什么情况下能包自己？&lt;/p&gt;
&lt;p&gt;当时正在实现一个类似链表的功能，在一个节点中需要有下个节点的引用的数据，比如像这样子的代码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Node&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在Node中有一个Node类型的引用地址，用来找到这个节点的下一个节点。默认构造函数调用后会将data置0,Next置null,当时我写到这里突然想起来好像在哪里看到过类中包含类自己是不行的。于是在Console中跑了一遍，运行结果是对的。断点显示初始化的值是我预计的结果。那到底在什么情况下类不能包含自己呢？要知道答案，我们还是先要说说初始化背后的故事。&lt;/p&gt;
&lt;p&gt;在我初始化节点的时候我调用的是new
Node()这个方法，这个时候.Net会首先计算类中成员需要的内存空间，这里就是int类型和Node引用类型的地址的空间(实际还有别的，不过和我们讨论的问题无关，故在这里省略)，然后在内存中分配内存空间，分配了内存空间后就会对类中的变量进行初始化，比如我的代码中写的是public
int data =
3;那么data这个变量就会在这时被赋值3,就变量初始化后然后会调用类的相应的构造函数，因为我这里没有实现构造函数，所以最后的值就是data的值为0,Node的值为null(引用类型的默认初始化值都是null).&lt;/p&gt;
&lt;p&gt;到这里我们已经把类的初始化过程弄的比较清楚了，现在要做的就是如何改变代码使程序异常。我们把注意力放到public Node Next; 这一句上，这里我没有加new Node(),这个方法，所以Next的值为0，现在我们在后面把初始化类的代码加上。就像这样&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Node&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;       
    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;Next&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;好了，现在让我们来想一下Next这个地方的值是怎么样的，data置0后，new Node需要返回给Next一个内存中的地址，所以它需要再次运行类的初始化的代码，在内存中重新开辟区域，给data置0,然后里面显然也有一个Node类型的引用，当给data赋值后，我也需要给那个Next赋值，然后又需要在内存中开辟区域。这样永无止境，直到内存耗而报错。&lt;/p&gt;
&lt;p&gt;到这里关于类能否包含自己相信我们已经找到了答案了。另外需要在提的一点就是如果类中的自己是静态变量呢？静态变量是属于类级别的，它的初始化是在类初始化的时候，如果没有调用构造函数，变量置null,如果调用了构造函数，则按构造函数进行初始化。如果构造函数中出现了上面的这种情况，一样的会报异常。&lt;/p&gt;
&lt;p&gt;类中能否包含自己听来多是一种经验，但是如果你真正弄清楚了里面的过程以及为什么为异常的原因，相信你犯错的机会会小的多。&lt;/p&gt;</summary></entry><entry><title>MSchart与Zedgraph使用初探及比较</title><link href="http://blog.michaelyin.info/2010/11/25/mschart-zedgraph/" rel="alternate"></link><updated>2010-11-25T01:59:00+08:00</updated><author><name>Michaelyin</name></author><id>tag:blog.michaelyin.info,2010-11-25:2010/11/25/mschart-zedgraph/</id><summary type="html">&lt;p&gt;最近项目中的统计图表功能需要重新进行下调整，所以这两天花时间学习了下关于统计图表方面的东西。&lt;/p&gt;
&lt;p&gt;统计图表的实现方式常用的有Flash方式和图片方式，我这两天主要是把MsChart和Zedgraph研究了一下，简单说下MSchart，这个图表解决方案是微软官方提供的图表解决方案，使用的时候需要.Net3.5
Sp1（在一篇文章的评论中看到有人说.net2.0中也能用，只是需要把需要用到的dll手动加到bin文件夹中去），然后需要安装一个文件，也就是把几个需要用到的dll放到机器里面去。然后有一个安装文件在你的VS中安装控件，这样你就可以通过拖拉的方式直接在项目中使用mschart，需要注意的是在拖拉控件的同时它会修改你的Web.Config文件，当然了，如果你不想在toolbox中加入控件，也可以不安装VS控件，直接在项目中编码的方式来使用就行了，在重复一遍，Mschart.exe那个是必须要装的。如果你想进一步了解Mschart的使用，微软网站上有一个关于这个控件使用的样例项目，里面关于这个控件的例子已经写的很全面了。&lt;/p&gt;
&lt;p&gt;相比于Zedgraph，Mschart对前台声明式的编程支持的更好，很多东西都可以通过在前台声明来控制。Chart这个标记代表了整个控件，Legends这个标记是整个Chart的说明，Series代表Chart中的一连串数据，比如折线图中的一连串数据点就是一个Series，你可以向里面插入Points这个对象，来完成数据的绑定。ChartArea是作图区域，一个Chart控件中可以有几个ChartArea,比如如果有两个ChartArea的话生成的图就会有两个图表，AxisY和AxisX下提供了基本的控制样式的属性.&lt;/p&gt;
&lt;p&gt;Mschart支持多种数据源的绑定，而且和.Net本身的结合的夜更紧密，比如&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Chart1.Series["Series1"].Points.DataBindXY(myReader, "TimeDetail",
myReader, "Temperature");&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这句代码就是直接通过一个DataReader绑定到Chart控件中，你只需要指定DataReader和字段值，然后数据就会自己绑定到mschart上去，坐标轴的间距都可以自己根据具体的数据生成，你也可以通过编程手动的来制定左边的最小，最大值，以及坐标的间距，这些在我前面提到的样例代码中都有，有兴趣的可以自己去看。&lt;/p&gt;
&lt;p&gt;Mschart使用过程中发现的唯一有点点不爽的就是它的中间的线默认是画上去的，也就是那个Gridline,如果你的背景是纯色的还好，将颜色设置成一样就没事了，如果是渐变的背景，就没有办法找到合适的方法，只能把颜色调的淡一点，不过效果始终不是太好看。&lt;/p&gt;
&lt;p&gt;在来说说Zedgraph，这个控件以前在我看的bugnet中作者使用它来生成统计图表信息，当时也没多做了解，这几天花时间看了下，这个控件整体思路和Mschart其实差不多，都是后台动态绑定数据生成图片然后显示到页面上面，由于项目不是大批量的访问，所以性能方面我也没有作过多的分析和了解。&lt;/p&gt;
&lt;p&gt;它主要是通过后台编程来实现功能，不像Mschart很多可以通过声明来实现，MasterPane是一个主要的作图的pane,它是一个容器类，里面装着若干个GraphPane，这个GraphPane其实就和mschart中的ChartArea差不多，都是一个一个的小图，你还可以对MasterPane进行排列，管理图表的排列情况，PointPairList是数据容器，x轴和y轴对应的数据就装在这个里面然后进行绑定。调用的时候，对于Zedgraph需要将方法注册到控件的RenderGraph事件中去。&lt;/p&gt;
&lt;p&gt;总体来说实现效果和mschart其实差不多，只不过个人感觉Mschart好看一点点，而ZedGraph显得简练一些。&lt;/p&gt;</summary></entry><entry><title>Random 学习笔记</title><link href="http://blog.michaelyin.info/2010/10/20/random-generate/" rel="alternate"></link><updated>2010-10-20T12:44:00+08:00</updated><author><name>Michaelyin</name></author><id>tag:blog.michaelyin.info,2010-10-20:2010/10/20/random-generate/</id><summary type="html">&lt;p&gt;这几天在学习算法，所以生成随机数组就不可避免了，以前只是知道Random
这个类是用来生成随机数的但是没怎么用过，这次正好趁这个机会好好了解一下，在园子里面看了下别人写的文章和代码，自己又在VS里面跑了几次，这里就把一些觉得useful的东东记下来。&lt;/p&gt;
&lt;p&gt;Random是用来生成伪随机数的类，它根据生成对象时候的随机种子进行复杂的计算，然后生成伪随机数。如果我们在调用构造函数的时候没有指定随机种子，那么默认情况下它会采用系统的时间产生的值来做随机种子，这样的话那么我们在一次函数调用里面不同的Random对象有可能是采用相同的随机种子，那么有可能造成生成重复的随机数。关于随机种子的选取问题，等下会专门讲解。Random里面要用到比较多的方法就是obj.Next()这个方法，用于根据随机种子按照复杂的算法生成伪随机数，这个方法有多个重载的方法，可以限定需要生成的数字的最大值和最小值，基本上Random经常使用的就是这么几个东西。&lt;/p&gt;
&lt;p&gt;下面来讲一下如何避免生成重复的随机种子，以此来避免产生一连串重复的随机数。其实关键点就在于生成随机数的随机种子必须不一样，一种方法就是采用Guid.NewGuid().GetHashCode()来当做随机种子，由于Guid重复的可能性非常小，而且Hash算法不同的输入产生的结果也是不同的，所以可以很好的解决随机种子相同的问题。还有一种方法就是采用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DateTime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Now&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Ticks&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;span class="n"&gt;Random&lt;/span&gt; &lt;span class="n"&gt;ran&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Random&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="p"&gt;&amp;amp;&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="n"&gt;xffffffffL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tick&lt;/span&gt; &lt;span class="p"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="m"&gt;32&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个方法来达到效果&lt;/p&gt;
&lt;p&gt;园子里面有的朋友是用算法来完成生成不重复随机数的，这样可以完全避免重复数据的发生。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="nf"&gt;CreateInstanceType2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;Random&lt;/span&gt; &lt;span class="n"&gt;random&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Random&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;repeat&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="m"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;++)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;repeat&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;11&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;++)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="p"&gt;==&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;repeat&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(!&lt;/span&gt;&lt;span class="n"&gt;repeat&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;//循环变量-1,下一次for循环继续针对这个变量值进行&lt;/span&gt;
            &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个算法执行的思想就是每次生成后面的结果的时候都和前面所生成的结果进行比较，如果有比较的则把for循环中的i减小一次，下一次循环的时候重新生成，这是一种思路&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;15&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="m"&gt;15&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;++)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;Random&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Random&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="c1"&gt;//用来保存随机生成的不重复的10个数&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;site&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;15&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//设置下限&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="m"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;++)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;site&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;//在随机位置取出一个数，保存到结果数组&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="c1"&gt;//最后一个数复制到当前位置&lt;/span&gt;
    &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;site&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="c1"&gt;//位置的下限减少一&lt;/span&gt;
    &lt;span class="n"&gt;site&lt;/span&gt;&lt;span class="p"&gt;--;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;另外一种思想是首先在另外一个数组中把需要生成的结果生成，然后通过生成随机位置来确保唯一不重复随机数组。&lt;/p&gt;
&lt;p&gt;上面提到的几种方式应该根据实际情况具体确定使用方法，一般情况下在项目中如果需要用到Random的话把它设为全局的然后直接拿来调用是种不错的使用方式。&lt;/p&gt;</summary></entry></feed>