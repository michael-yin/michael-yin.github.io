<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Michaelyin's Blog</title><link href="http://blog.michaelyin.info/" rel="alternate"></link><link href="http://blog.michaelyin.info/feeds/suan-fa-xiang-guan.atom.xml" rel="self"></link><id>http://blog.michaelyin.info/</id><updated>2013-07-14T22:43:00+08:00</updated><entry><title>直线相交问题</title><link href="http://blog.michaelyin.info/2013/07/14/%e7%9b%b4%e7%ba%bf%e7%9b%b8%e4%ba%a4%e9%97%ae%e9%a2%98/" rel="alternate"></link><updated>2013-07-14T22:43:00+08:00</updated><author><name>MichaelYin</name></author><id>tag:blog.michaelyin.info,2013-07-14:2013/07/14/%e7%9b%b4%e7%ba%bf%e7%9b%b8%e4%ba%a4%e9%97%ae%e9%a2%98/</id><summary type="html">&lt;p&gt;最近在checkio上扫题的时候，碰到一个判断直线是否相交的问题，题目请&lt;a href="http://www.checkio.org/mission/task/info/bullet-and-wall/python-3/"&gt;猛击这里&lt;/a&gt;，这个题目以前上学的时候做到手软的好么，二话不说直接开写，先根据坐标上的两个点，算出斜率，然后得出直线表达式，最后根据两个直线表达式算出是否存在相交点，然后加上斜率为无穷大的情况等等，最后写出的代码如下。&lt;/p&gt;
&lt;p&gt;[code lang="py"]&lt;br /&gt;
def checkio(data):&lt;br /&gt;
xw1, yw1 = data[0]&lt;br /&gt;
xw2, yw2 = data[1]&lt;br /&gt;
xa, ya = data[2]&lt;br /&gt;
xb, yb = data[3]&lt;/p&gt;
&lt;p&gt;if(xw1 - xw2 == 0 and xb - xa == 0):&lt;br /&gt;
# vertical vertical&lt;br /&gt;
return False&lt;br /&gt;
elif(xw1 - xw2 == 0 and xb - xa != 0):&lt;br /&gt;
# ver hor&lt;br /&gt;
slope, d = cal_line(xa, ya, xb, yb)&lt;br /&gt;
y = xw1 * slope + d&lt;br /&gt;
dir = direction(data[2], data[3])&lt;br /&gt;
if(min(yw1, yw2) &amp;lt;= y &amp;lt;= max (yw1, yw2) and dir == 'left' and xw1 &amp;lt;=
xa):&lt;br /&gt;
return True&lt;br /&gt;
elif((min(yw1, yw2) &amp;lt;= y &amp;lt;= max (yw1, yw2) and dir == 'right' and xw1
&gt;= xa)):&lt;br /&gt;
return True&lt;br /&gt;
else:&lt;br /&gt;
return False&lt;br /&gt;
elif(xb - xa == 0 and xw1 - xw2 != 0):&lt;br /&gt;
# hor ver&lt;br /&gt;
slope, d = cal_line(xw1, yw1, xw2, yw2)&lt;br /&gt;
y = xa * slope + d&lt;br /&gt;
dir = direction(data[2], data[3])&lt;br /&gt;
if(min(xw1, xw2) &amp;lt;= xa &amp;lt;= max (xw1, xw2)and dir == 'down' and y &amp;lt;=
ya):&lt;br /&gt;
return True&lt;br /&gt;
elif(min(xw1, xw2) &amp;lt;= xa &amp;lt;= max (xw1, xw2) and dir == 'up' and y &gt;=
ya):&lt;br /&gt;
return True&lt;br /&gt;
else:&lt;br /&gt;
return False&lt;br /&gt;
else:&lt;br /&gt;
# other&lt;br /&gt;
return common(data)&lt;/p&gt;
&lt;p&gt;def common(data):&lt;br /&gt;
# common circumstance&lt;br /&gt;
xw1, yw1 = data[0]&lt;br /&gt;
xw2, yw2 = data[1]&lt;br /&gt;
xa, ya = data[2]&lt;br /&gt;
xb, yb = data[3]&lt;/p&gt;
&lt;p&gt;slope_wall = float(yw1 - yw2) / float(xw1 - xw2)&lt;br /&gt;
slopex = float(yb - ya) / float(xb - xa)&lt;/p&gt;
&lt;p&gt;d_wall = yw2 - slope_wall * xw2&lt;br /&gt;
d_x = yb - slopex * xb&lt;/p&gt;
&lt;p&gt;dir = direction(data[2], data[3])&lt;/p&gt;
&lt;p&gt;if(slope_wall == slopex and d_x != d_wall):&lt;br /&gt;
return False&lt;br /&gt;
elif(slope_wall == slopex and d_x == d_wall):&lt;br /&gt;
if(dir == "left" and min(xw1, xw2) &amp;lt;= xa):&lt;br /&gt;
return True&lt;br /&gt;
elif(dir == "right" and max(xw1, xw2) &gt;= xa):&lt;br /&gt;
return True&lt;br /&gt;
else:&lt;br /&gt;
return False&lt;br /&gt;
else:&lt;br /&gt;
point_x = round(float(d_wall - d_x) / float(slopex - slope_wall),
1)&lt;br /&gt;
point_y = round(point_x * slope_wall + d_wall, 1)&lt;/p&gt;
&lt;p&gt;if(dir == "right" and point_x &gt;= xa and min(xw1, xw2) &amp;lt;= point_x &amp;lt;=
max(xw1, xw2) and min(yw1, yw2) &amp;lt;= point_y &amp;lt;= max(yw1, yw2)):&lt;br /&gt;
return True&lt;br /&gt;
elif(dir == "left" and point_x &amp;lt;= xa and min(xw1, xw2) &amp;lt;= point_x &amp;lt;=
max(xw1, xw2) and min(yw1, yw2) &amp;lt;= point_y &amp;lt;= max(yw1, yw2)):&lt;br /&gt;
return True&lt;br /&gt;
else:&lt;br /&gt;
return False&lt;/p&gt;
&lt;p&gt;def direction(start, end):&lt;br /&gt;
xa, ya = start&lt;br /&gt;
xb, yb = end&lt;/p&gt;
&lt;p&gt;if(xa == xb and xa &gt; xb):&lt;br /&gt;
return 'down'&lt;br /&gt;
elif(xa == xb and xa &amp;lt; xb):&lt;br /&gt;
return 'up'&lt;br /&gt;
elif(xa != xb and xa &gt; xb):&lt;br /&gt;
return 'left'&lt;br /&gt;
elif(xa != xb and xa &amp;lt; xb):&lt;br /&gt;
return 'right'&lt;/p&gt;
&lt;p&gt;def cal_line(x1, y1, x2, y2):&lt;br /&gt;
slope = float(y1 - y2) / float(x1 - x2)&lt;br /&gt;
d = y1 - slope * x1&lt;br /&gt;
return [slope, d]&lt;/p&gt;
&lt;p&gt;# These "asserts" using only for self-checking and not necessary for
auto-testing&lt;br /&gt;
if __name__ == '__main__':&lt;br /&gt;
checkio([[9, 7], [2, 5], [5, 3], [2, 5]])&lt;br /&gt;
[/code]&lt;/p&gt;
&lt;p&gt;在调试了若干遍以后，程序是能跑起来了，但是这个程序，有这样几个问题。&lt;/p&gt;
&lt;p&gt;1：计算过程中基本不可避免的会牵扯到浮点数的计算，而这种计算需要小心小心再小心。&lt;/p&gt;
&lt;p&gt;2：浮点数中的误差等等问题在判断是否相交的时候是很麻烦的，我在程序里面使用了round让测试用例跑过了，但是并不意味着这样做就是合适的。&lt;/p&gt;
&lt;p&gt;在查看checkio别人的slution的时候，发现此类题还有另外一种解法，即改变坐标系，用另外一种思路来考虑此问题，而且不用担心相交点的判定问题&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.michaelyin.info/images/2013/07/image7.png"&gt;&lt;img alt="image" src="http://blog.michaelyin.info/images/2013/07/image_thumb7.png" title="image" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果直线AB和W1W2相交，那么AB的角度是是介于AW2和AW1的&lt;/p&gt;
&lt;p&gt;[code lang="py"]&lt;br /&gt;
import math&lt;br /&gt;
def checkio(data):&lt;br /&gt;
xw1, yw1 = data[0]&lt;br /&gt;
xw2, yw2 = data[1]&lt;br /&gt;
xa, ya = data[2]&lt;br /&gt;
xb, yb = data[3]&lt;/p&gt;
&lt;p&gt;w1 = math.atan2(yw1-ya, xw1-xa) % (2*math.pi)&lt;br /&gt;
w2 = math.atan2(yw2-ya, xw2-xa) % (2*math.pi)&lt;br /&gt;
b = math.atan2(yb-ya, xb-xa) % (2*math.pi)&lt;/p&gt;
&lt;p&gt;l, r = min(w1, w2), max(w1, w2)&lt;br /&gt;
l, r = (r, (l + 2*math.pi)) if (l + 2*math.pi - r &amp;lt; r - l) else (l,
r)&lt;/p&gt;
&lt;p&gt;# point on the wall edge&lt;br /&gt;
if data[2] in data[:2]: return True&lt;/p&gt;
&lt;p&gt;# point on the wall&lt;br /&gt;
if abs((r-l) - math.pi) &amp;lt; 1e-10: return True&lt;/p&gt;
&lt;p&gt;# regular business&lt;br /&gt;
return (l &amp;lt;= b &amp;lt;= r) or (l &amp;lt;= b + 2*math.pi &amp;lt;= r)&lt;br /&gt;
if __name__ == '__main__':&lt;br /&gt;
assert checkio([[0,0], [0,2], [5,1], [3,1]]) == True, "First"&lt;br /&gt;
[/code]&lt;/p&gt;</summary><category term="bullet-and-wall"></category><category term="checkio"></category></entry><entry><title>数组分割</title><link href="http://blog.michaelyin.info/2013/06/30/%e6%95%b0%e7%bb%84%e5%88%86%e5%89%b2/" rel="alternate"></link><updated>2013-06-30T12:01:00+08:00</updated><author><name>MichaelYin</name></author><id>tag:blog.michaelyin.info,2013-06-30:2013/06/30/%e6%95%b0%e7%bb%84%e5%88%86%e5%89%b2/</id><summary type="html">&lt;p&gt;最近在做Python
Challenge的时候无意中发现了checkio这个练习PY的地方，题目不难，正好可以在工作之余修炼下PY功力。。&lt;/p&gt;
&lt;p&gt;loading-cargo这个题目的意思比较简单
，有一个无序、元素个数为2n的正整数数组，要求：如何能把这个数组分割为两个子数组，子数组的元素个数不限，并使两个子数组之和最接近&lt;/p&gt;
&lt;h6&gt;1:Solve&lt;/h6&gt;
&lt;h6&gt;&lt;/h6&gt;
&lt;p&gt;根据题目给出的Hint，可以使用暴力破解的方式穷举出所有可能的组合，并算出其和，使用PY提供的库可以很方便的做到，代码如下&lt;/p&gt;
&lt;p&gt;[code lang="py"]import itertools&lt;/p&gt;
&lt;p&gt;def checkio(data):&lt;br /&gt;
total = sum(data)&lt;br /&gt;
diff = total&lt;br /&gt;
for i in range(1, len(data)):&lt;br /&gt;
for value in itertools.combinations(data, i):&lt;br /&gt;
diff_sub = sum(value)&lt;br /&gt;
diff_sub = total - 2 * diff_sub&lt;br /&gt;
if(diff_sub &amp;gt;= 0 and diff_sub &amp;lt; diff):&lt;br /&gt;
diff = diff_sub&lt;br /&gt;
return diff[/code]&lt;/p&gt;
&lt;h6&gt;2:Optimize&lt;/h6&gt;
&lt;p&gt;穷举解法并不是很优化的解法，因为其中需要穷举出所有的组合，然后根据组合算出分组的和，然后进行判断。&lt;/p&gt;
&lt;p&gt;此题其实可以采用DP(动态规划)来解决，现假定S(n)表示n个数字可能取值的集合，比如数字为
[1,2]，那么S(1) = [0,1] S(2) = [0,1,2,3]&lt;/p&gt;
&lt;p&gt;假设现在有2n个数字，假设前面2n-1个数字的(可能包含，也可能不包含)可能取的和的集合为S(2n-1)那么S(2n)有两部分组成，S(2n)
= S(2n-1) + (S(2n-1) + data[2n])，相加以后需要注意去掉重复值&lt;/p&gt;
&lt;p&gt;这样最后得到的S(2n)
就是2n个数字所能取的所有值的集合，对集合进行处理就能得到最后结果了，代码如下：&lt;/p&gt;
&lt;p&gt;[code lang="py"]def checkio(data):&lt;br /&gt;
ls = [None for i in range(len(data) + 1)]&lt;br /&gt;
ls[0] = [0]&lt;/p&gt;
&lt;p&gt;for i in range(1, len(data) + 1):&lt;br /&gt;
preset = set(map(lambda x:x + data[i - 1], ls[i - 1]))&lt;br /&gt;
now = set(ls[i - 1])&lt;br /&gt;
ls[i] = preset | now&lt;/p&gt;
&lt;p&gt;total = sum(data)&lt;br /&gt;
diff = total&lt;br /&gt;
for value in ls[-1]:&lt;br /&gt;
if(0 &amp;lt;= total - 2 * value &amp;lt; diff):&lt;br /&gt;
diff = total - 2 * value&lt;br /&gt;
return diff[/code]&lt;/p&gt;
&lt;h6&gt;3:Expand&lt;/h6&gt;
&lt;p&gt;如果你恰好看过编程之美的话，那么你会发现编程之美中的一题和此题十分类似。有一个无序、元素个数为2n的正整数数组，要求：如何能把这个数组分割为元素个数为n的两个数组，并使两个子数组之和最接近&lt;/p&gt;
&lt;p&gt;相对于前面的问题，编程之美只是对分割后数组的个数有了要求，而本身的实质还是没有变的。假设A[i][j]表示在前面i个数中取j个数的可能的和的集合，那么&lt;/p&gt;
&lt;p&gt;A[i][j] = A[i-1][j] + A[i-1][j-1] +
data[j]，比较上面的S公式，可以看到只是对于数字的个数有了更具体的要求，而i本身其实在这个问题里面不是说特别重要了，对问题稍微抽象一下的话，可以写出代码：&lt;/p&gt;
&lt;p&gt;[code lang="py"]def checkio(data):&lt;br /&gt;
n = len(data) // 2&lt;br /&gt;
ls = [[0] for i in range(len(data) + 1)]&lt;br /&gt;
for i in range(1, len(data) + 1):&lt;br /&gt;
for j in range(min(n, i), 0, -1):&lt;br /&gt;
preset = set(map(lambda x:x + data[i - 1], ls[j - 1]))&lt;br /&gt;
now = set(ls[j])&lt;br /&gt;
ls[j] = preset | now&lt;/p&gt;
&lt;p&gt;total = sum(data)&lt;br /&gt;
diff = total&lt;br /&gt;
for value in ls[n]:&lt;br /&gt;
if(0 &amp;lt;= total - 2 * value &amp;lt; diff):&lt;br /&gt;
diff = total - 2 * value&lt;br /&gt;
return diff[/code]&lt;/p&gt;
&lt;h6&gt;4:Conclude&lt;/h6&gt;
&lt;p&gt;其实上面的问题和常见的01背包问题是很类似的，所以用典型的01背包问题的解法来解的话也是能够做出来的，关键是弄清楚其中的联系。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/tianshuai11/article/details/7828907"&gt;点击这里&lt;/a&gt;可查看本问题解法的C++代码&lt;/p&gt;</summary><category term="checkio"></category><category term="动态规划"></category><category term="数组分割"></category></entry></feed>